"""
Задание 1.
Создать класс TrafficLight (светофор)
и определить у него один приватный атрибут color (цвет) и публичный метод running (запуск).
В рамках метода running реализовать переключение светофора в режимы:
красный, желтый, зеленый. Продолжительность первого состояния (красный)
составляет 7 секунд, второго (желтый) — 2 секунды, третьего (зеленый) —
на ваше усмотрение.
Для имитации "горения" каждого цвета испольщуйте ф-цию sleep модуля time
Переключение между режимами должно осуществляться только
в указанном порядке (красный, желтый, зеленый).
Проверить работу примера, создав экземпляр и вызвав описанный метод.
"""

import time


class TrafficLight:
    """Класс, описывающий работу светофора."""

    def __init__(self):
        """конструктор"""
        self.__color = ["красный", "жёлтый", "зелёный"]

    def running(self):
        """метод, переключающий цвет светофора"""
        i = 0
        while i < len(self.__color):
            print(self.__color[i])
            if i == 0:
                time.sleep(7)  # красный
            if i == 1:
                time.sleep(2)  # жёлтый
            if i == 2:
                time.sleep(5)  # зелёный
            i = i + 1

        return TrafficLight.running(self)


crossroad_point = TrafficLight()

crossroad_point.running()

"""
Задание 2.
Реализовать класс Road (дорога), в котором определить защищенные атрибуты:
length (длина в метрах), width (ширина в метрах).
Значения данных атрибутов должны передаваться при создании экземпляра класса.
Реализовать публичный метод расчета массы асфальта, необходимого для покрытия
всего дорожного полотна.
Использовать формулу: длина * ширина * масса асфальта для покрытия одного кв
метра дороги асфальтом, толщиной в 1 см * число м толщины полотна.
Массу и толщину сделать публичными атрибутами.
Проверить работу метода.
Например: 20м*5000м*25кг*0.05м = 125000 кг = 125 т
"""


class Road:
    """Класс расчета массы асфальта для дорожного полотна, все значения указаны в метрах"""

    def __init__(self):
        """Конструктор"""
        self.mass = 25  # масса асфальта, кг
        self.thick = 0.05  # толщина асфальта, м (1 см = 0.05 м)
        self._length = 0  # длина, м
        self._width = 0  # ширина, м

    def calc_mass(self, length, width):
        """
        Метод возвращающий результат расчета количества материала
        длина * ширина * масса * толщина = результат в тоннах
        """
        self._length = length
        self._width = width
        return self._length * self._width * self.mass * self.thick / 1000


build = Road()
print(build.calc_mass(20, 5000))

"""
Задание 3.
Реализовать базовый класс Worker (работник),
в котором определить публичные атрибуты name, surname, position (должность),
и защищенный атрибут income (доход). Последний атрибут должен ссылаться
на словарь, содержащий элементы: оклад и премия, например, {"wage": wage, "bonus": bonus}.
Создать класс Position (должность) на базе класса Worker. В классе Position реализовать публичные методы
получения полного имени сотрудника (get_full_name) и дохода с учетом премии (get_total_income).
Проверить работу примера на реальных данных (создать экземпляры класса Position, передать данные,
проверить значения атрибутов, вызвать методы экземпляров).
П.С. попытайтесь добить вывода информации о сотруднике также через перегрузку __str__
__str__(self) - вызывается функциями str, print и format. Возвращает строковое представление объекта.
"""


class Worker:
    """класс работника"""

    def __init__(self, wage, bonus):
        self.name = 'не указано'
        self.surname = 'не указано'
        self.position = 'не указано'
        self._income = {"wage": wage, "bonus": bonus}


class Position(Worker):
    """класс Position, наследующий класс Worker"""

    def __init__(self, wage, bonus):
        """
        Конструктор. Поскольку атрибут родительского класса _income защищен,
        пришлось создать две переменные, self.wage и self.bonus для
        использования в методе get_total_income
        """
        super().__init__(wage, bonus)
        self.wage = wage
        self.bonus = bonus

    def get_full_name(self):
        """Метод получения полного имени сотрудника"""
        return f"{self.name} {self.surname}"

    def __str__(self):
        """Альтернативный метод вывода полного имени сотрудника"""
        return '{} {}'.format(self.name, self.surname)

    def get_total_income(self):
        """Метод получения полного дохода сотрудника"""
        return self.wage + self.bonus


"""Проверка: Создание экземпляра класса Position и передача им значений:"""
unit1 = Position(1000, 100)
unit1.name = 'Иван'
unit1.surname = 'Петров'
unit1.position = 'Техник'

print(f"Проверка значений первого экземпляра: {unit1.__dict__}\n"
      f"Полное имя сотрудника: {unit1.get_full_name()}"  # проверка метода .get_full_name
      f"\nПолный доход: {unit1.get_total_income()}")  # проверка метода .get_total_income
# {'name': 'Иван', 'surname': 'Петров', 'position': 'Техник', '_income': {'wage': 1000, 'bonus': 100}, 'wage': 1000, 'bonus': 100}
# Полное имя сотрудника: Иван Петров
# Полный доход: 1100
print(unit1.__str__())  # Иван Петров

unit2 = Position(2000, 200)
unit2.name = 'Петя'
unit2.surname = 'Иванов'
unit2.position = 'Специалист'

print(f"Проверка значений второго экземпляра: {unit2.__dict__}\n"
      f"Полное имя сотрудника: {unit2.get_full_name()}"  # проверка метода .get_full_name
      f"\nПолный доход: {unit2.get_total_income()}")  # проверка метода .get_total_income
# Проверка значений второго экземпляра: {'name': 'Петя', 'surname': 'Иванов', 'position': 'Специалист', '_income': {'wage': 2000, 'bonus': 200}, 'wage': 2000, 'bonus': 200}
# Полное имя сотрудника: Петя Иванов
# Полный доход: 2200
print(unit2.__str__())  # Петя Иванов

"""
Задание 4.
Реализуйте базовый класс Car. У данного класса должны быть следующие публичные атрибуты:
speed, color, name, is_police (булево).
А также публичные методы: go, stop, turn(direction),
которые должны сообщать, что машина поехала, остановилась, повернула (куда).
Опишите несколько дочерних классов: TownCar, SportCar, WorkCar, PoliceCar.
Добавьте в базовый класс публичный метод show_speed,
который должен показывать текущую скорость автомобиля.
Для классов TownCar и WorkCar переопределите метод show_speed.
При значении скорости свыше 60 (TownCar)
и 40 (WorkCar) должно выводиться сообщение о превышении скорости.
Создайте экземпляры классов, передайте значения атрибутов.
Выполните доступ к атрибутам, выведите результат.
Выполните вызов методов и также покажите результат.
"""


class Auto:
    """Основной шаблонный класс, описывающий параметры машины"""

    def __init__(self):
        """Конструктор"""
        self.speed = 30
        self.color = "Серая"
        self.name = "Ford"
        self.is_police = False

    def go(self):
        """Метод, запускающий движение машины"""
        print(f"{self.color} машина {self.name} поехала")

    def stop(self):
        """Метод, останавливающий машину"""
        print(f"{self.color} машина {self.name} остановилась")

    def turn(self, direction):
        """Метод, который поворачивает машину по принятому аргументу"""
        print(f"{self.color} машина {self.name} повернула {direction}")

    def show_speed(self):
        """Метод, показывающий скорость машины"""
        print(f"{self.color} машина {self.name} едет со скоростью {self.speed}")


class TownCar(Auto):
    """Дочерний класс, описывающий городской автомобиль с переопределением некоторых атрибутов"""

    def __init__(self):
        """Конструктор, переопределяет 3 атрибута родительского класса"""
        super().__init__()
        self.speed = 50
        self.color = "Зеленая"
        self.name = "Nissan"

    def show_speed(self):
        """Переопределенный метод показа и контроля превышения скорости"""
        print(f"{self.color} машина {self.name} едет со скоростью {self.speed}")
        if self.speed > 60:
            print("Внимание, машина едет с превышением скорости!")


class SportCar(Auto):
    """Дочерний класс, описывающий спортивную машину"""

    def __init__(self):
        """Конструктор, переопределяет 3 атрибута родительского класса"""
        super().__init__()
        self.speed = 150
        self.color = "Жёлтая"
        self.name = "Lamborgini"


class WorkCar(Auto):
    """Дочерний класс, описывающий грузовую машину"""

    def __init__(self):
        """Конструктор, переопределяет 3 атрибута родительского класса"""
        super().__init__()
        self.speed = 30
        self.color = "Черная"
        self.name = "Grumman LLV"

    def show_speed(self):
        """Переопределенный метод показа и контроля превышения скорости"""
        print(f"{self.color} машина {self.name} едет со скоростью {self.speed}")
        if self.speed > 40:
            print("Внимание, скорость превышена!")


class PoliceCar(Auto):
    """Родительский класс, описывающий полицейскую машину"""

    def __init__(self):
        """Конструктор, переопределяет 3 атрибута родительского класса"""
        super().__init__()
        self.speed = 80
        self.color = "Полицейская"
        self.is_police = True


a = Auto()
print(a.__dict__)  # {'speed': 30, 'color': 'Серая', 'name': 'Ford', 'is_police': False}
a.show_speed()  # Серая машина Ford едет со скоростью 30

b = TownCar()
print(b.__dict__)  # {'speed': 50, 'color': 'Зеленая', 'name': 'Nissan', 'is_police': False}
b.show_speed()  # Зеленая машина Nissan едет со скоростью 50
b.speed = 90
b.show_speed()  # Зеленая машина Nissan едет со скоростью 90 # Внимание, машина едет с превышением скорости!

c = SportCar()
print(c.__dict__)  # {'speed': 150, 'color': 'Жёлтая', 'name': 'Lamborgini', 'is_police': False}
c.show_speed()  # Жёлтая машина Lamborgini едет со скоростью 150
c.stop()  # Жёлтая машина Lamborgini остановилась
c.go()  # Жёлтая машина Lamborgini поехала
c.turn("направо")  # Жёлтая машина Lamborgini повернула направо
c.speed = 100
print(c.__dict__)  # {'speed': 100, 'color': 'Жёлтая', 'name': 'Lamborgini', 'is_police': False}

d = WorkCar()
print(d.__dict__)  # {'speed': 30, 'color': 'Черная', 'name': 'Grumman LLV', 'is_police': False}
d.show_speed()  # Черная машина Grumman LLV едет со скоростью 30
d.speed = 80
d.show_speed()  # Черная машина Grumman LLV едет со скоростью 80  # Внимание, скорость превышена!
d.stop()  # Черная машина Grumman LLV остановилась

f = PoliceCar()
print(f.__dict__)  # {'speed': 80, 'color': 'Полицейская', 'name': 'Ford', 'is_police': True}
f.show_speed()  # Полицейская машина Ford едет со скоростью 80
f.turn("налево")  # Полицейская машина Ford повернула налево
f.stop()  # Полицейская машина Ford остановилась

g = PoliceCar()
print(g.__dict__)  # {'speed': 80, 'color': 'Полицейская', 'name': 'Ford', 'is_police': True}
g.name = "Chevrolet Camaro"
g.speed = 120
print(g.__dict__)  # {'speed': 120, 'color': 'Полицейская', 'name': 'Chevrolet Camaro', 'is_police': True}

"""
Задание 5.
Реализовать класс Stationery (канцелярская принадлежность).
Определить в нем публичный атрибут title (название) и публичный метод draw (отрисовка).
Метод выводит сообщение “Запуск отрисовки.”
Создать три дочерних класса: Pen (ручка), Pencil (карандаш), Handle (маркер).
В каждом из классов реализовать переопределение метода draw.
Для каждого из классов метод должен выводить уникальное сообщение.
Создать экземпляры классов и проверить, что выведет описанный метод для каждого экземпляра.
"""


class Stationery:
    """Шаблонный класс канцелярской принадлежности"""

    def __init__(self):
        self.title = "название канцелярской принадлежности"

    def draw(self):
        """Метод отрисовки"""
        print("Запуск отрисовки")


class Pen(Stationery):
    """Дочерний класс, описывающий ручку"""

    def __init__(self):
        """Конструктор, переопределяет 1 атрибут родительского класса"""
        super().__init__()
        self.title = "Ручка"

    def draw(self):
        """Метод запуска рукописи ручкой"""
        print("Запуск рукописи ручкой")


class Pencil(Stationery):
    """Дочерний класс, описывающий карандаш"""

    def __init__(self):
        """Конструктор, переопределяет 1 атрибут родительского класса"""
        super().__init__()
        self.title = "Карандаш"

    def draw(self):
        """Метод отрисовки карандашом"""
        print("Запуск отрисовки карандашом")


class Handle(Stationery):
    """Дочерний класс, описывающий маркер"""

    def __init__(self):
        """Конструктор, переопределяет 1 атрибут родительского класса"""
        super().__init__()
        self.title = "Маркер"

    def draw(self):
        """Метод запуска маркирования"""
        print("Запуск маркирования")


u_pen = Pen()
print(u_pen.title)  # Ручка
u_pen.draw()  # Запуск рукописи ручкой

u_pencil = Pencil()
print(u_pencil.title)  # Карандаш
u_pencil.draw()  # Запуск отрисовки карандашом

u_handle = Handle()
print(u_handle.title)  # Маркер
u_handle.draw()  # Запуск маркирования
